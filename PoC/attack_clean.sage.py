# This file was *autogenerated* from the file attack_clean.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_163 = Integer(163); _sage_const_0x04f3e6ddffc4ba45282f3fabe0e8a220b98980387a = Integer(0x04f3e6ddffc4ba45282f3fabe0e8a220b98980387a); _sage_const_5846006549323611672814742442876390689256843201587 = Integer(5846006549323611672814742442876390689256843201587); _sage_const_35 = Integer(35)# Config
lattice_size = _sage_const_35    # number of signatures
trick = _sage_const_2 **_sage_const_163  / _sage_const_2 **_sage_const_8  # 7 leading bits
print trick

# Get data
with open("nonces_155.log", "r") as f:
    content = f.readlines()

digests = []
signatures = []

# Parse it
for item in content[:lattice_size]:
    data = item.strip("\n")
    data = data.split(" ")
    data = list(truc.strip("L") for truc in data)
    data = map(int, data)
    digests.append(data[_sage_const_1 ])
    signatures.append((data[_sage_const_2 ], data[_sage_const_3 ]))

# get public key x coordinate
pubx = _sage_const_0x04f3e6ddffc4ba45282f3fabe0e8a220b98980387a 

# and public key modulo
# taken from NIST or FIPS (http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf)
modulo = _sage_const_5846006549323611672814742442876390689256843201587 

# Building Equations
nn = len(digests)

# getting rid of the first equation
r0_inv = inverse_mod(signatures[_sage_const_0 ][_sage_const_0 ], modulo)
s0 = signatures[_sage_const_0 ][_sage_const_1 ]
m0 = digests[_sage_const_0 ]

AA = [-_sage_const_1 ]
BB = [_sage_const_0 ]

for ii in range(_sage_const_1 , nn):
    mm = digests[ii]
    rr = signatures[ii][_sage_const_0 ]
    ss = signatures[ii][_sage_const_1 ]
    ss_inv = inverse_mod(ss, modulo)

    AA_i = Mod(-_sage_const_1  * s0 * r0_inv * rr * ss_inv, modulo)
    BB_i = Mod(-_sage_const_1  * mm * ss_inv + m0 * r0_inv * rr * ss_inv, modulo)
    AA.append(AA_i.lift())
    BB.append(BB_i.lift())

# Embedding Technique (CVP->SVP)
lattice = Matrix(ZZ, nn + _sage_const_1 )

# Fill lattice
for ii in range(nn):
    lattice[ii, ii] = modulo
    lattice[_sage_const_0 , ii] = AA[ii]

BB.append(trick)
lattice[nn] = vector(BB)

# LLL
lattice = lattice.LLL() # should get better results with BKZ instead of LLL

# If a solution is found, format it
if lattice[_sage_const_0 ,-_sage_const_1 ] % modulo == trick:
    # get rid of (..., 1)
    vec = list(lattice[_sage_const_0 ])
    vec.pop()
    vec = vector(vec)
    solution = -_sage_const_1  * vec
    
    # get d
    rr = signatures[_sage_const_0 ][_sage_const_0 ]
    ss = signatures[_sage_const_0 ][_sage_const_1 ]
    mm = digests[_sage_const_0 ]
    nonce = solution[_sage_const_0 ]

    key = Mod((ss * nonce - mm) * inverse_mod(rr, modulo), modulo)
    
    print "found a key"
    print key
